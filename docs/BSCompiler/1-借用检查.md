# 借用检查

## 1-DefUse 
### 1.1-定义

类 DefUse 对单个的 Stmt 进行分析，内部定义了 Defs 和 Uses 两个数组，分别存储 当前定义和使用的变量。
```cpp
class DefUse : public clang::StmtVisitor<DefUse> {
  enum { None, Def, Use } Action;
  llvm::SmallVector<VarDecl *> defs;
  llvm::SmallVector<VarDecl *> uses;
public:
  DefUse(Stmt *S) {
    Action = None;
    Visit(S);
  }
```
### 2-Visit函数
Visit 函数的调用针对以下特定的几个语句进行解析：

- BinaryOperator
- BinAssign
- CallExpr
- DeclRefExpr
- DeclStmt
- MemberExpr
- ReturnStmt
- UnaryDeref
- UnaryOperator

#### 例如： BinaryOperator


通过 opcode 判断检查：

- 1>算数运算符
  - BO_Mul (* 乘法)
  - BO_Div (/ 除法)
  - BO_Rem (% 取模)
  - BO_Add (+ 加法)
  - BO_Sub (- 减法)
  - BO_Shl (<< 左移)
  - BO_Shr (>> 右移)
- 2>位运算符
  - BO_And (& 按位与)
  - BO_Xor (^ 按位异或)
  - BO_Or (| 按位或)
  - BO_LAnd (&& 逻辑与)
  - BO_LOr (|| 逻辑或)
- 3>关系运算符
  - BO_LT (< 小于)
  - BO_GT (> 大于)
  - BO_LE (<= 小于等于)
  - BO_GE (>= 大于等于)
  - BO_EQ (== 等于)
  - BO_NE (!= 不等于) 
- 4>复合赋值运算符
  - BO_MulAssign		乘法赋值（a *= b）
  - BO_DivAssign		除法赋值（a /= b）
  - BO_RemAssign		取模赋值（a %= b）
  - BO_AddAssign		加法赋值（a += b）
  - BO_SubAssign		减法赋值（a -= b）
  - BO_ShlAssign		左移赋值（a <<= b）
  - BO_ShrAssign		右移赋值（a >>= b）
  - BO_AndAssign		按位与赋值（a &= b）
  - BO_XorAssign		按位异或赋值（a ^= b）
  - BO_OrAssign	 	按位或赋值（a |= b）
```cpp

void DefUse::VisitBinaryOperator(BinaryOperator *BO) {
  auto Opcode = BO->getOpcode();
  if ((Opcode >= BO_Mul && Opcode <= BO_Shr) ||
      (Opcode >= BO_And && Opcode <= BO_LOr) ||
      (Opcode >= BO_LT && Opcode <= BO_NE)) {
    Action = Use;
    Visit(BO->getLHS());
    Visit(BO->getRHS());
  } else if (Opcode >= BO_MulAssign && Opcode <= BO_OrAssign) {
    Action = Def;
    Visit(BO->getLHS());
    Action = Use;
    Visit(BO->getLHS());
    Visit(BO->getRHS());
  }
}
```

Visit(xxx) 到最终的 DeclRefExpr 通过 Action 来判断存入相应的数组中
```cpp
void DefUse::VisitDeclRefExpr(DeclRefExpr *DRE) {
  if (VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl())) {
    if (Action == Def) {
      defs.push_back(VD);
    } else if (Action == Use) {
      uses.push_back(VD);
    }
  }
}
```

## 2-Liveness 
类 Liveness 计算每个程序点上的活跃变量集合
```cpp
using LivenessFact = llvm::DenseSet<VarDecl *>;
llvm::DenseMap<const CFGBlock *, LivenessFact> liveness; //
```
liveness 用于保存基本块的所有活跃变量集合。

compute 函数迭代计算达到不动点停止
```cpp
bool SetFrom(LivenessFact &Dest, const LivenessFact &Src) {
    if (Src.empty())
      return false;

    unsigned old = Dest.size();
    Dest.insert(Src.begin(), Src.end());
    return old != Dest.size();
}

void Liveness::Compute() {
  llvm::DenseSet<VarDecl *> fact;

  bool changed = true;
  while (changed) {
    changed = false;
    //自底向上
    for (const CFGBlock *B : env.cfg.const_nodes()) {
        fact.clear();

        for (auto succ : B->succs()) { // 将所有后继 block 中的活跃变量存入当前的集合中
            if (succ)
            SetFrom(fact, liveness[succ]);
        }
        for (CFGBlock::const_reverse_iterator it = Block->rbegin(),ei = Block->rend(); it != ei; ++it) {
            if (elem.getAs<CFGStmt>()) {
                S = elem.castAs<CFGStmt>().getStmt();
                // Get the def-use information of a given statement.
                DefUse DU(const_cast<Stmt *>(S));
                const llvm::SmallVector<VarDecl *> &defs = DU.getDefs();
                const llvm::SmallVector<VarDecl *> &uses = DU.getUses();

                // Anything we write to is no longer live.
                for (VarDecl *def : defs) {
                    fact.erase(def);
                }

                // Any variables we read from, we make live.
                for (VarDecl *use : uses) {
                    fact.insert(uses);
                }
            }
        }
        changed |= SetFrom(liveness[B], fact); // 达到不动点的条件
    }
  }
}
```